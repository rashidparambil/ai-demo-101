from langchain_google_genai import ChatGoogleGenerativeAI
from api.config import config
from langchain.agents import create_agent
from api.chat_bot.tools import search_table_details_tool, execute_sql_tool
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List
import logging
import json

logger = logging.getLogger(__name__)

class ChatBotResponse(BaseModel):
    generated_sql: Optional[str] = Field(description="The SQL query generated by the agent")
    sql_result: Optional[List[Dict[str, Any]]] = Field(description="The result of the SQL query execution")
    final_answer: str = Field(description="The final natural language answer to the user's question")

class ChatBotService:
    def __init__(self):
        self.llm = ChatGoogleGenerativeAI(
            model="gemini-2.5-flash",
            temperature=0,
            max_retries=1,
            google_api_key=config.google_api_key
        )
        
        self.tools = [search_table_details_tool, execute_sql_tool]
        
        self.system_message = """You are a helpful data assistant. Your goal is to answer user questions by querying a database.
        
        Follow this strict process:
        1. Use `search_table_details_tool` to find relevant tables and schemas based on the user's question.
        2. Based on the schemas found, generate a valid SQL SELECT query.
        3. Use `execute_sql_tool` to execute the query.
        4. Verify the result.
        5. Formulate a final answer based on the query result.
        
        You must return a structured output containing:
        - generated_sql: The SQL query you executed.
        - sql_result: The raw result from the database.
        - final_answer: Your natural language response.
        
        Return ONLY valid JSON in the following format:
        {
            "generated_sql": "SELECT ...",
            "sql_result": [...],
            "final_answer": "..."
        }
        """
        
        self.agent = create_agent(self.llm, tools=self.tools, system_prompt=self.system_message)

    async def process_query(self, query: str) -> Dict[str, Any]:
        """
        Process a natural language query using the agent.
        """
        try:
            result = await self.agent.ainvoke({"messages": [{"role": "user", "content": query}]})
            
            # The result from create_agent (likely LangGraph prebuilt) usually has 'messages'
            # We need to extract the final response.
            final_content = result["messages"][-1].content
            
            # Handle case where content is a list (e.g. text + tool calls)
            if isinstance(final_content, list):
                # Extract text parts
                final_content = "".join([part if isinstance(part, str) else str(part) for part in final_content])
            
            # Try to parse JSON from the final content
            try:
                # Clean up markdown code blocks if present
                clean_content = final_content.replace("```json", "").replace("```", "").strip()
                parsed_result = json.loads(clean_content)
                return parsed_result
            except json.JSONDecodeError:
                # Fallback if not JSON
                return {
                    "generated_sql": None,
                    "sql_result": None,
                    "final_answer": final_content
                }
            
        except Exception as e:
            logger.error(f"Error processing query: {e}")
            return {
                "generated_sql": None,
                "sql_result": None,
                "final_answer": f"I encountered an error: {str(e)}"
            }
