from langchain_google_genai import ChatGoogleGenerativeAI
from api.config import config
from langchain.agents import create_agent
from api.chat_bot.tools import search_table_details_tool, execute_sql_tool
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List
import logging
import json
import re
from typing import Dict, Any

logger = logging.getLogger(__name__)

class ChatBotResponse(BaseModel):
    generated_sql: Optional[str] = Field(description="The SQL query generated by the agent")
    final_answer: Optional[str] = Field(..., description="Formatted answer with \n for line breaks")

class ChatBotService:
    def __init__(self):
        self.llm = ChatGoogleGenerativeAI(
            model="gemini-2.5-flash",
            temperature=0,
            max_retries=1,
            google_api_key=config.google_api_key
        )
        
        self.tools = [search_table_details_tool, execute_sql_tool]
        
        self.system_message = """You are a helpful data assistant. Your goal is to answer user questions by querying a database.
        
                Follow this strict process:
                1. Use `search_table_details_tool` to find relevant tables and schemas based on the user's question.
                2. **CRITICAL SHORT-CIRCUIT:** If `search_table_details_tool` returns no relevant tables (or an empty result), **STOP IMMEDIATELY**. Do NOT generate SQL. Proceed directly to final answer generation (Step 4).
                3. **SQL GENERATION:** Generate a valid SQL SELECT query based ONLY on the schema provided, using the table and column names exactly as provided.
                    a. **SECURITY:** ONLY generate SELECT queries. **NEVER** use DROP, DELETE, UPDATE, INSERT, or ALTER.
                    b. **RAG QUERIES (Rules/Policies):** If the question involves rules, use the `client_rule` table and its `embedding` column. **ALWAYS** join with the `client` table to look up client names (`c.name`).
                    c. **ANALYTICAL QUERIES (Standard):** Generate standard SELECT queries for simple counts, lists, or aggregates.
                    
                    **RAG SQL TEMPLATE (Copy and adapt for rule questions. Filters are optional):**
                    ```sql
                    SELECT cr.rule_content
                    FROM client_rule cr
                    INNER JOIN client c ON cr.client_id = c.id
                    WHERE c.name = '[CLIENT_NAME]' AND cr.process_type = [TYPE_ID] AND cr.is_auto_apply = [BOOL]
                    ORDER BY cr.embedding <-> EMBEDDING_FUNCTION('[USER_QUERY_OR_RULE_CONCEPT]') 
                    LIMIT 3;
                    ```

                4. You must return a structured output containing ONLY:
                    - generated_sql: The SQL query you executed, OR null if no tables were found and no query was executed.
                    - final_answer: Your natural language response and Formulate a final answer as a clean bullet-point list with \n between lines with proper result, do not include any sample data or SQL in the final answer.
                    
                    **IMPORTANT:** If no tables were found in Step 2, set generated_sql to null and generate the final answer based on that fact alone.
                    
                    **OUTPUT FORMAT EXAMPLE:**
                    
                    Return ONLY valid JSON in the following format:
                    {
                        "generated_sql": "SELECT ...",
                        "final_answer": "\n• Item 1\n• Item 2\n• Item 3"
                    }
                    """
        
        self.agent = create_agent(self.llm,
                                  tools=self.tools,
                                  system_prompt=self.system_message
                    )



    async def process_query(self, query: str) -> Dict[str, Any]:
        try:
            result = await self.agent.ainvoke({"messages": [{"role": "user", "content": query}]})
            final_response = result["messages"][-1].content
            raw_response = final_response[0]["text"][7:-3]
            formatedresponse : ChatBotResponse = json.loads(raw_response)
            return     formatedresponse
                
        except Exception as e:
            logger.error(f"Error processing query: {e}")
            return {
                "generated_sql": None,
                "final_answer": f"Error: {str(e)}"
            }


# --- Usage Example ---
if __name__ == "__main__":
    # Test the service
    service = ChatBotService()
    
    async def test_queries():
        test_queries = [
            "Which clients have 'Remove leading zero from account number' rule?",
            "Get list of rules",
            "Placement rules for client 123"
        ]
        
        for query in test_queries:
            result = await service.process_query(query)
            print(f"\nQuery: {query}")
            print(f"SQL: {result['generated_sql']}")
            print(f"Answer: {result['final_answer']}")
            print("-" * 80)
    
    import asyncio
    asyncio.run(test_queries())