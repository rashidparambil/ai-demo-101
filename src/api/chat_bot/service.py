from langchain_google_genai import ChatGoogleGenerativeAI
from api.config import config
from langchain.agents import create_agent
from api.chat_bot.tools import search_table_details_tool, execute_sql_tool
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List
import logging
import json
import re
from typing import Dict, Any

logger = logging.getLogger(__name__)

class ChatBotResponse(BaseModel):
    generated_sql: Optional[str] = Field(description="The SQL query generated by the agent")
    final_answer: str = Field(..., description="Formatted answer with \\n for line breaks")

class ChatBotService:
    def __init__(self):
        self.llm = ChatGoogleGenerativeAI(
            model="gemini-2.5-flash",
            temperature=0,
            max_retries=1,
            google_api_key=config.google_api_key
        )
        
        self.tools = [search_table_details_tool, execute_sql_tool]
        
        self.system_message =  """You are a helpful data assistant. Your goal is to answer user questions by querying a database.
        
                Follow this strict process:
                1. Use `search_table_details_tool` to find relevant tables and schemas based on the user's question.
                2. Based on the schemas found, generate a valid SQL SELECT query.
                3. Use `execute_sql_tool` to execute the query.
                4. **Do NOT include sql_result in your response** - just analyze the results internally.
                5. Formulate a final answer based on the query result.

                You must return a structured output containing ONLY:
                - generated_sql: The SQL query you executed
                - final_answer: Your natural language response and  Formulate a final answer as a clean bullet-point list with \n between lines.

                Return ONLY valid JSON in this format:
                {
                    "generated_sql": "SELECT ...",
                    "final_answer": "Summary:\n• Item 1\n• Item 2\n• Item 3"
                }
                """
        
        self.agent = create_agent(self.llm,
                                  tools=self.tools,
                                  system_prompt=self.system_message,
                                  response_format=ChatBotResponse  # Add this line
                    )



    async def process_query(self, query: str) -> Dict[str, Any]:
        try:
            result = await self.agent.ainvoke({"messages": [{"role": "user", "content": query}]})
            
            final_message = result["messages"][-1]
            
            # Try structuredResponse first
            if hasattr(final_message, 'structuredResponse') and final_message.structuredResponse:
                structured = final_message.structuredResponse.dict()
                return {
                    "generated_sql": structured.get("generated_sql"),
                    "final_answer": structured.get("final_answer")
                }
            
            # Regex for Gemini text format
            content_str = str(final_message.content)
            pattern = r"generated_sql='([^']+)'\s*final_answer='([^']+)'"
            match = re.search(pattern, content_str)
            
            if match:
                return {
                    "generated_sql": match.group(1),
                    "final_answer": match.group(2)
                }
            
            # JSON fallback
            clean_content = content_str.replace("```json", "").replace("```", "").strip()
            try:
                parsed = json.loads(clean_content)
                return {
                    "generated_sql": parsed.get("generated_sql"),
                    "final_answer": parsed.get("final_answer")
                }
            except json.JSONDecodeError:
                return {
                    "generated_sql": None,
                    "final_answer": content_str[:500]
                }
                
        except Exception as e:
            logger.error(f"Error processing query: {e}")
            return {
                "generated_sql": None,
                "final_answer": f"Error: {str(e)}"
            }